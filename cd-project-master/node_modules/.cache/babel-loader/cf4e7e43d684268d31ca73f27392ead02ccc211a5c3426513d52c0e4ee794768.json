{"ast":null,"code":"class TACGenerator {\n  constructor() {\n    this.tempCount = 1;\n    this.address = 100;\n    this.tacLines = [];\n    this.stack = [];\n  }\n  generateTAC(code) {\n    this.tempCount = 1;\n    this.address = 100;\n    this.tacLines = [];\n    this.stack = [];\n    const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line.startsWith(\"for\")) {\n        this.handleForLoop(line);\n      } else if (line.startsWith(\"if\")) {\n        this.handleIfStatement(line);\n      } else if (line.startsWith(\"else\")) {\n        this.handleElseStatement();\n      } else if (line === \"}\") {\n        this.handleBlockEnd();\n      } else if (line.includes(\"=\")) {\n        this.handleAssignment(line);\n      }\n    }\n    return this.tacLines.join(\"\\n\");\n  }\n  handleForLoop(line) {\n    var _line$match;\n    const iterator = (_line$match = line.match(/\\((.*?)\\)/)) === null || _line$match === void 0 ? void 0 : _line$match[1];\n    const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n\n    // Handle initialization\n    if (init) {\n      this.tacLines.push(`${this.address++}: ${init}`);\n    }\n    const loopStart = this.address;\n    const temp = `t${this.tempCount++}`;\n    this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n    const exitJump = this.address++;\n    this.tacLines.push(`${exitJump}: ifFalse ${temp} goto ?`);\n    this.stack.push({\n      type: 'for',\n      exitJump,\n      loopStart,\n      increment,\n      temp,\n      startAddress: loopStart\n    });\n  }\n  handleIfStatement(line) {\n    var _line$match2;\n    const condition = (_line$match2 = line.match(/\\((.*?)\\)/)) === null || _line$match2 === void 0 ? void 0 : _line$match2[1];\n    const temp = `t${this.tempCount++}`;\n    this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n    const elseJump = this.address++;\n    this.tacLines.push(`${elseJump}: ifFalse ${temp} goto ?`);\n    this.stack.push({\n      type: 'if',\n      elseJump,\n      temp,\n      startAddress: this.address\n    });\n  }\n  handleElseStatement() {\n    const prev = this.stack.pop();\n    if (prev && prev.type === 'if') {\n      const endIfJump = this.address++;\n      this.tacLines.push(`${endIfJump}: goto ?`);\n      this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n      this.stack.push({\n        type: 'else',\n        endIfJump,\n        startAddress: this.address\n      });\n    }\n  }\n  handleBlockEnd() {\n    const prev = this.stack.pop();\n    if (!prev) return;\n    switch (prev.type) {\n      case 'for':\n        if (prev.increment) {\n          this.tacLines.push(`${this.address++}: ${prev.increment}`);\n        }\n        this.tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n        this.tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n        break;\n      case 'else':\n        this.tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n        break;\n      case 'if':\n        this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n        break;\n    }\n  }\n  handleAssignment(line) {\n    const [varName, expr] = line.split(\"=\").map(x => x.trim());\n    if (!expr) return;\n\n    // Handle complex expressions\n    const parts = expr.split(/([+\\-*/])/).map(p => p.trim()).filter(p => p);\n    if (parts.length > 1) {\n      // Handle binary operations\n      let result = parts[0];\n      for (let j = 1; j < parts.length; j += 2) {\n        const op = parts[j];\n        const right = parts[j + 1];\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${result} ${op} ${right}`);\n        result = temp;\n      }\n      this.tacLines.push(`${this.address++}: ${varName} = ${result}`);\n    } else {\n      // Handle simple assignment\n      const temp = `t${this.tempCount++}`;\n      this.tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n      this.tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n    }\n  }\n}\nmodule.exports = TACGenerator;","map":{"version":3,"names":["TACGenerator","constructor","tempCount","address","tacLines","stack","generateTAC","code","lines","split","map","line","trim","filter","i","length","startsWith","handleForLoop","handleIfStatement","handleElseStatement","handleBlockEnd","includes","handleAssignment","join","_line$match","iterator","match","init","condition","increment","s","push","loopStart","temp","exitJump","type","startAddress","_line$match2","elseJump","prev","pop","endIfJump","varName","expr","x","parts","p","result","j","op","right","module","exports"],"sources":["C:/VISEM/cd-project-tac/tac-generator/src/TACGenerator.js"],"sourcesContent":["class TACGenerator {\n    constructor() {\n        this.tempCount = 1;\n        this.address = 100;\n        this.tacLines = [];\n        this.stack = [];\n    }\n\n    generateTAC(code) {\n        this.tempCount = 1;\n        this.address = 100;\n        this.tacLines = [];\n        this.stack = [];\n\n        const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n        \n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            \n            if (line.startsWith(\"for\")) {\n                this.handleForLoop(line);\n            } \n            else if (line.startsWith(\"if\")) {\n                this.handleIfStatement(line);\n            } \n            else if (line.startsWith(\"else\")) {\n                this.handleElseStatement();\n            } \n            else if (line === \"}\") {\n                this.handleBlockEnd();\n            } \n            else if (line.includes(\"=\")) {\n                this.handleAssignment(line);\n            }\n        }\n\n        return this.tacLines.join(\"\\n\");\n    }\n\n    handleForLoop(line) {\n        const iterator = line.match(/\\((.*?)\\)/)?.[1];\n        const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n        \n        // Handle initialization\n        if (init) {\n            this.tacLines.push(`${this.address++}: ${init}`);\n        }\n        \n        const loopStart = this.address;\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const exitJump = this.address++;\n        this.tacLines.push(`${exitJump}: ifFalse ${temp} goto ?`);\n        \n        this.stack.push({\n            type: 'for',\n            exitJump,\n            loopStart,\n            increment,\n            temp,\n            startAddress: loopStart\n        });\n    }\n\n    handleIfStatement(line) {\n        const condition = line.match(/\\((.*?)\\)/)?.[1];\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const elseJump = this.address++;\n        this.tacLines.push(`${elseJump}: ifFalse ${temp} goto ?`);\n        \n        this.stack.push({\n            type: 'if',\n            elseJump,\n            temp,\n            startAddress: this.address\n        });\n    }\n\n    handleElseStatement() {\n        const prev = this.stack.pop();\n        if (prev && prev.type === 'if') {\n            const endIfJump = this.address++;\n            this.tacLines.push(`${endIfJump}: goto ?`);\n            this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n            this.stack.push({\n                type: 'else',\n                endIfJump,\n                startAddress: this.address\n            });\n        }\n    }\n\n    handleBlockEnd() {\n        const prev = this.stack.pop();\n        if (!prev) return;\n\n        switch (prev.type) {\n            case 'for':\n                if (prev.increment) {\n                    this.tacLines.push(`${this.address++}: ${prev.increment}`);\n                }\n                this.tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n                this.tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                break;\n            case 'else':\n                this.tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n                break;\n            case 'if':\n                this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                break;\n        }\n    }\n\n    handleAssignment(line) {\n        const [varName, expr] = line.split(\"=\").map(x => x.trim());\n        if (!expr) return;\n\n        // Handle complex expressions\n        const parts = expr.split(/([+\\-*/])/).map(p => p.trim()).filter(p => p);\n        if (parts.length > 1) {\n            // Handle binary operations\n            let result = parts[0];\n            for (let j = 1; j < parts.length; j += 2) {\n                const op = parts[j];\n                const right = parts[j + 1];\n                const temp = `t${this.tempCount++}`;\n                this.tacLines.push(`${this.address++}: ${temp} = ${result} ${op} ${right}`);\n                result = temp;\n            }\n            this.tacLines.push(`${this.address++}: ${varName} = ${result}`);\n        } else {\n            // Handle simple assignment\n            const temp = `t${this.tempCount++}`;\n            this.tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n            this.tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n        }\n    }\n}\n\nmodule.exports = TACGenerator; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}