{"ast":null,"code":"class TACGenerator {\n  constructor() {\n    this.tempCount = 1;\n    this.address = 100;\n    this.tacLines = [];\n    this.stack = [];\n    this.labels = new Map();\n  }\n  generateTAC(code) {\n    this.tempCount = 1;\n    this.address = 100;\n    this.tacLines = [];\n    this.stack = [];\n    this.labels.clear();\n    const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line.startsWith(\"for\")) {\n        this.handleForLoop(line);\n      } else if (line.startsWith(\"if\")) {\n        this.handleIfStatement(line);\n      } else if (line.startsWith(\"else\")) {\n        this.handleElseStatement();\n      } else if (line === \"}\") {\n        this.handleBlockEnd();\n      } else if (line.includes(\"=\")) {\n        this.handleAssignment(line);\n      }\n    }\n\n    // Resolve all labels\n    return this.resolveLabels();\n  }\n  handleForLoop(line) {\n    var _line$match;\n    const iterator = (_line$match = line.match(/\\((.*?)\\)/)) === null || _line$match === void 0 ? void 0 : _line$match[1];\n    const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n\n    // Handle initialization\n    if (init) {\n      this.tacLines.push(`${this.address++}: ${init}`);\n    }\n    const loopStart = this.address;\n    const temp = `t${this.tempCount++}`;\n    this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n    const exitJump = this.address++;\n    this.tacLines.push(`${exitJump}: ifFalse ${temp} goto L${this.address}`);\n    this.stack.push({\n      type: 'for',\n      exitJump,\n      loopStart,\n      increment,\n      temp,\n      startAddress: loopStart,\n      label: `L${this.address}`\n    });\n  }\n  handleIfStatement(line) {\n    var _line$match2;\n    const condition = (_line$match2 = line.match(/\\((.*?)\\)/)) === null || _line$match2 === void 0 ? void 0 : _line$match2[1];\n    const temp = `t${this.tempCount++}`;\n    this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n    const elseJump = this.address++;\n    this.tacLines.push(`${elseJump}: ifFalse ${temp} goto L${this.address}`);\n    this.stack.push({\n      type: 'if',\n      elseJump,\n      temp,\n      startAddress: this.address,\n      label: `L${this.address}`\n    });\n  }\n  handleElseStatement() {\n    const prev = this.stack.pop();\n    if (prev && prev.type === 'if') {\n      const endIfJump = this.address++;\n      this.tacLines.push(`${endIfJump}: goto L${this.address}`);\n      this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n      this.stack.push({\n        type: 'else',\n        endIfJump,\n        startAddress: this.address,\n        label: `L${this.address}`\n      });\n    }\n  }\n  handleBlockEnd() {\n    const prev = this.stack.pop();\n    if (!prev) return;\n    switch (prev.type) {\n      case 'for':\n        if (prev.increment) {\n          this.tacLines.push(`${this.address++}: ${prev.increment}`);\n        }\n        this.tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n        this.tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n        break;\n      case 'else':\n        this.tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n        break;\n      case 'if':\n        this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n        break;\n    }\n  }\n  handleAssignment(line) {\n    const [varName, expr] = line.split(\"=\").map(x => x.trim());\n    if (!expr) return;\n\n    // Handle complex expressions\n    const parts = expr.split(/([+\\-*/])/).map(p => p.trim()).filter(p => p);\n    if (parts.length > 1) {\n      // Handle binary operations\n      let result = parts[0];\n      for (let j = 1; j < parts.length; j += 2) {\n        const op = parts[j];\n        const right = parts[j + 1];\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${result} ${op} ${right}`);\n        result = temp;\n      }\n      this.tacLines.push(`${this.address++}: ${varName} = ${result}`);\n    } else {\n      // Handle simple assignment\n      const temp = `t${this.tempCount++}`;\n      this.tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n      this.tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n    }\n  }\n  resolveLabels() {\n    let resolvedLines = [];\n    let currentAddress = 100;\n    for (const line of this.tacLines) {\n      if (line.includes('goto L')) {\n        const [prefix, label] = line.split('goto L');\n        const targetAddress = parseInt(label);\n        resolvedLines.push(`${currentAddress++}: ${prefix}goto ${targetAddress}`);\n      } else {\n        resolvedLines.push(`${currentAddress++}: ${line.split(': ')[1]}`);\n      }\n    }\n    return resolvedLines.join('\\n');\n  }\n}\nmodule.exports = TACGenerator;","map":{"version":3,"names":["TACGenerator","constructor","tempCount","address","tacLines","stack","labels","Map","generateTAC","code","clear","lines","split","map","line","trim","filter","i","length","startsWith","handleForLoop","handleIfStatement","handleElseStatement","handleBlockEnd","includes","handleAssignment","resolveLabels","_line$match","iterator","match","init","condition","increment","s","push","loopStart","temp","exitJump","type","startAddress","label","_line$match2","elseJump","prev","pop","endIfJump","varName","expr","x","parts","p","result","j","op","right","resolvedLines","currentAddress","prefix","targetAddress","parseInt","join","module","exports"],"sources":["C:/VISEM/cd-project-tac/tac-generator/src/TACGenerator.js"],"sourcesContent":["class TACGenerator {\n    constructor() {\n        this.tempCount = 1;\n        this.address = 100;\n        this.tacLines = [];\n        this.stack = [];\n        this.labels = new Map();\n    }\n\n    generateTAC(code) {\n        this.tempCount = 1;\n        this.address = 100;\n        this.tacLines = [];\n        this.stack = [];\n        this.labels.clear();\n\n        const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n        \n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            \n            if (line.startsWith(\"for\")) {\n                this.handleForLoop(line);\n            } \n            else if (line.startsWith(\"if\")) {\n                this.handleIfStatement(line);\n            } \n            else if (line.startsWith(\"else\")) {\n                this.handleElseStatement();\n            } \n            else if (line === \"}\") {\n                this.handleBlockEnd();\n            } \n            else if (line.includes(\"=\")) {\n                this.handleAssignment(line);\n            }\n        }\n\n        // Resolve all labels\n        return this.resolveLabels();\n    }\n\n    handleForLoop(line) {\n        const iterator = line.match(/\\((.*?)\\)/)?.[1];\n        const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n        \n        // Handle initialization\n        if (init) {\n            this.tacLines.push(`${this.address++}: ${init}`);\n        }\n        \n        const loopStart = this.address;\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const exitJump = this.address++;\n        this.tacLines.push(`${exitJump}: ifFalse ${temp} goto L${this.address}`);\n        \n        this.stack.push({\n            type: 'for',\n            exitJump,\n            loopStart,\n            increment,\n            temp,\n            startAddress: loopStart,\n            label: `L${this.address}`\n        });\n    }\n\n    handleIfStatement(line) {\n        const condition = line.match(/\\((.*?)\\)/)?.[1];\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const elseJump = this.address++;\n        this.tacLines.push(`${elseJump}: ifFalse ${temp} goto L${this.address}`);\n        \n        this.stack.push({\n            type: 'if',\n            elseJump,\n            temp,\n            startAddress: this.address,\n            label: `L${this.address}`\n        });\n    }\n\n    handleElseStatement() {\n        const prev = this.stack.pop();\n        if (prev && prev.type === 'if') {\n            const endIfJump = this.address++;\n            this.tacLines.push(`${endIfJump}: goto L${this.address}`);\n            this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n            this.stack.push({\n                type: 'else',\n                endIfJump,\n                startAddress: this.address,\n                label: `L${this.address}`\n            });\n        }\n    }\n\n    handleBlockEnd() {\n        const prev = this.stack.pop();\n        if (!prev) return;\n\n        switch (prev.type) {\n            case 'for':\n                if (prev.increment) {\n                    this.tacLines.push(`${this.address++}: ${prev.increment}`);\n                }\n                this.tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n                this.tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                break;\n            case 'else':\n                this.tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n                break;\n            case 'if':\n                this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                break;\n        }\n    }\n\n    handleAssignment(line) {\n        const [varName, expr] = line.split(\"=\").map(x => x.trim());\n        if (!expr) return;\n\n        // Handle complex expressions\n        const parts = expr.split(/([+\\-*/])/).map(p => p.trim()).filter(p => p);\n        if (parts.length > 1) {\n            // Handle binary operations\n            let result = parts[0];\n            for (let j = 1; j < parts.length; j += 2) {\n                const op = parts[j];\n                const right = parts[j + 1];\n                const temp = `t${this.tempCount++}`;\n                this.tacLines.push(`${this.address++}: ${temp} = ${result} ${op} ${right}`);\n                result = temp;\n            }\n            this.tacLines.push(`${this.address++}: ${varName} = ${result}`);\n        } else {\n            // Handle simple assignment\n            const temp = `t${this.tempCount++}`;\n            this.tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n            this.tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n        }\n    }\n\n    resolveLabels() {\n        let resolvedLines = [];\n        let currentAddress = 100;\n\n        for (const line of this.tacLines) {\n            if (line.includes('goto L')) {\n                const [prefix, label] = line.split('goto L');\n                const targetAddress = parseInt(label);\n                resolvedLines.push(`${currentAddress++}: ${prefix}goto ${targetAddress}`);\n            } else {\n                resolvedLines.push(`${currentAddress++}: ${line.split(': ')[1]}`);\n            }\n        }\n\n        return resolvedLines.join('\\n');\n    }\n}\n\nmodule.exports = TACGenerator; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}