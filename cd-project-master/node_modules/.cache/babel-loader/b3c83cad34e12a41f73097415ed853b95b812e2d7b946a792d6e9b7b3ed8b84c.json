{"ast":null,"code":"class TACGenerator {\n  constructor() {\n    this.tempCount = 1;\n    this.address = 100;\n  }\n  generateTAC(code) {\n    this.tempCount = 1;\n    this.address = 100;\n    const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n    let tacLines = [];\n    let stack = [];\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      if (line.startsWith(\"for\")) {\n        var _line$match;\n        const iterator = (_line$match = line.match(/\\((.*?)\\)/)) === null || _line$match === void 0 ? void 0 : _line$match[1];\n        const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n\n        // Handle initialization\n        if (init) {\n          tacLines.push(`${this.address++}: ${init}`);\n        }\n        const loopStart = this.address;\n        const temp = `t${this.tempCount++}`;\n        tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const exitJump = this.address++;\n        tacLines.push(`${exitJump}: ifFalse ${temp} goto ?`);\n        stack.push({\n          type: 'for',\n          exitJump,\n          loopStart,\n          increment,\n          temp\n        });\n      } else if (line.startsWith(\"if\")) {\n        var _line$match2;\n        const condition = (_line$match2 = line.match(/\\((.*?)\\)/)) === null || _line$match2 === void 0 ? void 0 : _line$match2[1];\n        const temp = `t${this.tempCount++}`;\n        tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const elseJump = this.address++;\n        tacLines.push(`${elseJump}: ifFalse ${temp} goto ?`);\n        stack.push({\n          type: 'if',\n          elseJump,\n          temp\n        });\n      } else if (line.startsWith(\"else\")) {\n        const prev = stack.pop();\n        if (prev && prev.type === 'if') {\n          const endIfJump = this.address++;\n          tacLines.push(`${endIfJump}: goto ?`);\n          tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n          stack.push({\n            type: 'else',\n            endIfJump\n          });\n        }\n      } else if (line === \"}\") {\n        const prev = stack.pop();\n        if (!prev) continue;\n        if (prev.type === 'for') {\n          // Handle loop end\n          if (prev.increment) {\n            tacLines.push(`${this.address++}: ${prev.increment}`);\n          }\n          tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n          tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n        } else if (prev.type === 'else') {\n          // Handle else end\n          tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n        }\n      } else if (line.includes(\"=\")) {\n        const [varName, expr] = line.split(\"=\").map(x => x.trim());\n        if (expr) {\n          const temp = `t${this.tempCount++}`;\n          tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n          tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n        }\n      }\n    }\n    return tacLines.join(\"\\n\");\n  }\n}\nmodule.exports = TACGenerator;","map":{"version":3,"names":["TACGenerator","constructor","tempCount","address","generateTAC","code","lines","split","map","line","trim","filter","tacLines","stack","i","length","startsWith","_line$match","iterator","match","init","condition","increment","s","push","loopStart","temp","exitJump","type","_line$match2","elseJump","prev","pop","endIfJump","includes","varName","expr","x","join","module","exports"],"sources":["C:/VISEM/cd-project-tac/tac-generator/src/TACGenerator.js"],"sourcesContent":["class TACGenerator {\n    constructor() {\n        this.tempCount = 1;\n        this.address = 100;\n    }\n\n    generateTAC(code) {\n        this.tempCount = 1;\n        this.address = 100;\n\n        const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n        let tacLines = [];\n        let stack = [];\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            \n            if (line.startsWith(\"for\")) {\n                const iterator = line.match(/\\((.*?)\\)/)?.[1];\n                const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n                \n                // Handle initialization\n                if (init) {\n                    tacLines.push(`${this.address++}: ${init}`);\n                }\n                \n                const loopStart = this.address;\n                const temp = `t${this.tempCount++}`;\n                tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n                const exitJump = this.address++;\n                tacLines.push(`${exitJump}: ifFalse ${temp} goto ?`);\n                \n                stack.push({\n                    type: 'for',\n                    exitJump,\n                    loopStart,\n                    increment,\n                    temp\n                });\n            } \n            \n            else if (line.startsWith(\"if\")) {\n                const condition = line.match(/\\((.*?)\\)/)?.[1];\n                const temp = `t${this.tempCount++}`;\n                tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n                const elseJump = this.address++;\n                tacLines.push(`${elseJump}: ifFalse ${temp} goto ?`);\n                \n                stack.push({\n                    type: 'if',\n                    elseJump,\n                    temp\n                });\n            } \n            \n            else if (line.startsWith(\"else\")) {\n                const prev = stack.pop();\n                if (prev && prev.type === 'if') {\n                    const endIfJump = this.address++;\n                    tacLines.push(`${endIfJump}: goto ?`);\n                    tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                    stack.push({\n                        type: 'else',\n                        endIfJump\n                    });\n                }\n            } \n            \n            else if (line === \"}\") {\n                const prev = stack.pop();\n                if (!prev) continue;\n\n                if (prev.type === 'for') {\n                    // Handle loop end\n                    if (prev.increment) {\n                        tacLines.push(`${this.address++}: ${prev.increment}`);\n                    }\n                    tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n                    tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                }\n                else if (prev.type === 'else') {\n                    // Handle else end\n                    tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n                }\n            } \n            \n            else if (line.includes(\"=\")) {\n                const [varName, expr] = line.split(\"=\").map(x => x.trim());\n                if (expr) {\n                    const temp = `t${this.tempCount++}`;\n                    tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n                    tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n                }\n            }\n        }\n\n        return tacLines.join(\"\\n\");\n    }\n}\n\nmodule.exports = TACGenerator; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}