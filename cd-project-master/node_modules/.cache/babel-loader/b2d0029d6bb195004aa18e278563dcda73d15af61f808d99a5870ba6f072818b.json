{"ast":null,"code":"class TACGenerator{constructor(){this.tempCount=1;this.address=100;this.tacLines=[];this.stack=[];}generateTAC(code){this.tempCount=1;this.address=100;this.tacLines=[];this.stack=[];const lines=code.split(\"\\n\").map(line=>line.trim()).filter(line=>line);for(let i=0;i<lines.length;i++){const line=lines[i];if(line.startsWith(\"for\")){this.handleForLoop(line);}else if(line.startsWith(\"if\")){this.handleIfStatement(line);}else if(line.startsWith(\"else\")){this.handleElseStatement();}else if(line===\"}\"){this.handleBlockEnd();}else if(line.includes(\"=\")){this.handleAssignment(line);}}return this.tacLines.join(\"\\n\");}handleForLoop(line){var _line$match;const iterator=(_line$match=line.match(/\\((.*?)\\)/))===null||_line$match===void 0?void 0:_line$match[1];const[init,condition,increment]=iterator.split(\";\").map(s=>s.trim());// Handle initialization\nif(init){this.tacLines.push(`${this.address++}: ${init}`);}const loopStart=this.address;const temp=`t${this.tempCount++}`;this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);const exitJump=this.address++;this.tacLines.push(`${exitJump}: ifFalse ${temp} goto ?`);this.stack.push({type:'for',exitJump,loopStart,increment,temp,startAddress:loopStart});}handleIfStatement(line){var _line$match2;const condition=(_line$match2=line.match(/\\((.*?)\\)/))===null||_line$match2===void 0?void 0:_line$match2[1];const temp=`t${this.tempCount++}`;this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);const elseJump=this.address++;this.tacLines.push(`${elseJump}: ifFalse ${temp} goto ?`);this.stack.push({type:'if',elseJump,temp,startAddress:this.address});}handleElseStatement(){const prev=this.stack.pop();if(prev&&prev.type==='if'){const endIfJump=this.address++;this.tacLines.push(`${endIfJump}: goto ?`);this.tacLines[prev.elseJump]=`${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;this.stack.push({type:'else',endIfJump,startAddress:this.address});}}handleBlockEnd(){const prev=this.stack.pop();if(!prev)return;switch(prev.type){case'for':if(prev.increment){this.tacLines.push(`${this.address++}: ${prev.increment}`);}this.tacLines.push(`${this.address++}: goto ${prev.loopStart}`);this.tacLines[prev.exitJump]=`${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;break;case'else':this.tacLines[prev.endIfJump]=`${prev.endIfJump}: goto ${this.address}`;break;case'if':this.tacLines[prev.elseJump]=`${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;break;}}handleAssignment(line){const[varName,expr]=line.split(\"=\").map(x=>x.trim());if(!expr)return;// Handle complex expressions\nconst parts=expr.split(/([+\\-*/])/).map(p=>p.trim()).filter(p=>p);if(parts.length>1){// Handle binary operations\nlet result=parts[0];for(let j=1;j<parts.length;j+=2){const op=parts[j];const right=parts[j+1];const temp=`t${this.tempCount++}`;this.tacLines.push(`${this.address++}: ${temp} = ${result} ${op} ${right}`);result=temp;}this.tacLines.push(`${this.address++}: ${varName} = ${result}`);}else{// Handle simple assignment\nconst temp=`t${this.tempCount++}`;this.tacLines.push(`${this.address++}: ${temp} = ${expr}`);this.tacLines.push(`${this.address++}: ${varName} = ${temp}`);}}}module.exports=TACGenerator;","map":{"version":3,"names":["TACGenerator","constructor","tempCount","address","tacLines","stack","generateTAC","code","lines","split","map","line","trim","filter","i","length","startsWith","handleForLoop","handleIfStatement","handleElseStatement","handleBlockEnd","includes","handleAssignment","join","_line$match","iterator","match","init","condition","increment","s","push","loopStart","temp","exitJump","type","startAddress","_line$match2","elseJump","prev","pop","endIfJump","varName","expr","x","parts","p","result","j","op","right","module","exports"],"sources":["C:/VISEM/cd-project-tac/tac-generator/src/TACGenerator.js"],"sourcesContent":["class TACGenerator {\n    constructor() {\n        this.tempCount = 1;\n        this.address = 100;\n        this.tacLines = [];\n        this.stack = [];\n    }\n\n    generateTAC(code) {\n        this.tempCount = 1;\n        this.address = 100;\n        this.tacLines = [];\n        this.stack = [];\n\n        const lines = code.split(\"\\n\").map(line => line.trim()).filter(line => line);\n        \n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            \n            if (line.startsWith(\"for\")) {\n                this.handleForLoop(line);\n            } \n            else if (line.startsWith(\"if\")) {\n                this.handleIfStatement(line);\n            } \n            else if (line.startsWith(\"else\")) {\n                this.handleElseStatement();\n            } \n            else if (line === \"}\") {\n                this.handleBlockEnd();\n            } \n            else if (line.includes(\"=\")) {\n                this.handleAssignment(line);\n            }\n        }\n\n        return this.tacLines.join(\"\\n\");\n    }\n\n    handleForLoop(line) {\n        const iterator = line.match(/\\((.*?)\\)/)?.[1];\n        const [init, condition, increment] = iterator.split(\";\").map(s => s.trim());\n        \n        // Handle initialization\n        if (init) {\n            this.tacLines.push(`${this.address++}: ${init}`);\n        }\n        \n        const loopStart = this.address;\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const exitJump = this.address++;\n        this.tacLines.push(`${exitJump}: ifFalse ${temp} goto ?`);\n        \n        this.stack.push({\n            type: 'for',\n            exitJump,\n            loopStart,\n            increment,\n            temp,\n            startAddress: loopStart\n        });\n    }\n\n    handleIfStatement(line) {\n        const condition = line.match(/\\((.*?)\\)/)?.[1];\n        const temp = `t${this.tempCount++}`;\n        this.tacLines.push(`${this.address++}: ${temp} = ${condition}`);\n        const elseJump = this.address++;\n        this.tacLines.push(`${elseJump}: ifFalse ${temp} goto ?`);\n        \n        this.stack.push({\n            type: 'if',\n            elseJump,\n            temp,\n            startAddress: this.address\n        });\n    }\n\n    handleElseStatement() {\n        const prev = this.stack.pop();\n        if (prev && prev.type === 'if') {\n            const endIfJump = this.address++;\n            this.tacLines.push(`${endIfJump}: goto ?`);\n            this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n            this.stack.push({\n                type: 'else',\n                endIfJump,\n                startAddress: this.address\n            });\n        }\n    }\n\n    handleBlockEnd() {\n        const prev = this.stack.pop();\n        if (!prev) return;\n\n        switch (prev.type) {\n            case 'for':\n                if (prev.increment) {\n                    this.tacLines.push(`${this.address++}: ${prev.increment}`);\n                }\n                this.tacLines.push(`${this.address++}: goto ${prev.loopStart}`);\n                this.tacLines[prev.exitJump] = `${prev.exitJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                break;\n            case 'else':\n                this.tacLines[prev.endIfJump] = `${prev.endIfJump}: goto ${this.address}`;\n                break;\n            case 'if':\n                this.tacLines[prev.elseJump] = `${prev.elseJump}: ifFalse ${prev.temp} goto ${this.address}`;\n                break;\n        }\n    }\n\n    handleAssignment(line) {\n        const [varName, expr] = line.split(\"=\").map(x => x.trim());\n        if (!expr) return;\n\n        // Handle complex expressions\n        const parts = expr.split(/([+\\-*/])/).map(p => p.trim()).filter(p => p);\n        if (parts.length > 1) {\n            // Handle binary operations\n            let result = parts[0];\n            for (let j = 1; j < parts.length; j += 2) {\n                const op = parts[j];\n                const right = parts[j + 1];\n                const temp = `t${this.tempCount++}`;\n                this.tacLines.push(`${this.address++}: ${temp} = ${result} ${op} ${right}`);\n                result = temp;\n            }\n            this.tacLines.push(`${this.address++}: ${varName} = ${result}`);\n        } else {\n            // Handle simple assignment\n            const temp = `t${this.tempCount++}`;\n            this.tacLines.push(`${this.address++}: ${temp} = ${expr}`);\n            this.tacLines.push(`${this.address++}: ${varName} = ${temp}`);\n        }\n    }\n}\n\nmodule.exports = TACGenerator; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}